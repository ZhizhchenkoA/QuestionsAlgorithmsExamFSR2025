\section{Очереди с приоритетами. Наивная реализация, реализация на бинарной куче}
	
\subsection*{Очередь с приоритетом} 

Абстрактная структура данных, где у каждого элемента есть приоритет (некоторая величина, приписываемая каждому элементу, помимо значения, которую можно сравнить). 
Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. 
Если у элементов одинаковые приоритеты, они располагаются в зависимости от своей позиции в очереди.

\textbf{Очередь с приоритетом должна поддерживать стандартные операции:}

\begin{itemize}
	\item \texttt{findMin} или \texttt{findMax} --- поиск элемента с наибольшим приоритетом,
	\item \texttt{insert} или \texttt{push} --- вставка нового элемента,
	\item \texttt{extractMin} или \texttt{extractMax} --- извлечь элемент с наибольшим приоритетом,
	\item \texttt{increaseKey} или \texttt{decreaseKey} --- обновить значение элемента (данной операции, как в стандартной библиотеке C++, может и не быть)
\end{itemize}

\subsection*{Наивная реализация: (не)упорядоченный список/массив} % Подзаголовок без нумерации

В одной ячейке которого хранится key и val, где key --- приоритет.

\subsection{Неотсортированный список} % Подзаголовок без нумерации

\textbf{Вставка (insert):} Сложность: $O(1)$
\begin{itemize} 
	\item Создаётся новый узел, содержащий данные и приоритет.
	\item Новый узел вставляется в начало списка / конец массива.
\end{itemize}

\textbf{Поиск min/max:} Сложность: $O(n)$ 
\begin{itemize}
	\item Проходимся по списку, сравнивая на каждом шаге с текущим и, если больше, то обновляем.
	\item Сохраняем приоритет на 1 шаге.
\end{itemize}

\textbf{Изменение ключа элемента:} Сложность: $O(n)$ 

\subsection{Отсортированный массив:}

\textbf{Вставка (insert):} Сложность: $O(n)$ 
\begin{itemize}
	\item Создаём новый узел.
	\item Ищем его место в списке/массиве.
	\item Вставляем.
\end{itemize}

\textbf{Поиск max/min:} Сложность: $O(1)$ 
\begin{itemize}
	\item Первый/последний элемент списка/массива.
\end{itemize}

\textbf{Изменение ключа элемента:} $O(\log n)$ --- например, с помощью бинарного поиска.

\subsection{Реализация на бинарной куче }

См. билет 6

\begin{itemize}
	\item \textbf{Вставка:} $O(\log n)$ 
	\item \textbf{Поиск min/max:} $O(1)$ (если куча с min/max в корне) 
	\item \textbf{Изменение ключа элемента:} $O(\log n)$ 
\end{itemize}
