\section{Амортизационный анализ: метод потенциалов для динамического массива. }

Вместо представления предоплаченной работы в виде кредита, хранящегося в структуре данных вместе с отдельными объектами, в ходе амортизированного анализа по \textbf{методу потенциалов} (potential method) такая работа представляется в виде “потенциальной энергии”, или просто “потенциала”, который можно высвободить для оплаты последующих операций.
Этот потенциал связан со структурой данных в целом, а не с её отдельными объектами.

Метод потенциалов работает следующим образом. Мы начинаем с исходной структуры данных $D_0$, над которой выполняется $n$ операций.
Для всех $i = 1,2,...,n$ обозначим через $c_i$ фактическую стоимость $i$-й операции, а через $D_i$ --- структуру данных, которая получается в результате применения $i$-й операции к структуре данных $D_{i - 1}$.
\textbf{Функция потенциала} (potential function) $\Phi$ отоб
ражает каждую структуру данных $D_i$ на действительное число $\Phi(D_i)$, которое является \textbf{потенциалом} (potential), связанным со структурой данных $D_i$.
\textbf{Амортизированная стоимость} (amortized cost) $\hat{c_i}$ $i$-й операции определяется соотношением $$\hat{c_i} = c_i + \Phi(D_i) - \Phi(D_{i - 1}).$$
Таким образом, амортизированная стоимость каждой операции представляет собой ее фактическую стоимость плюс приращение потенциала в результате выполнения операции.
Тогда полная амортизированная стоимость $n$ операций равна $$\sum_{i = 1}^n \hat{c_i} = \sum_{i = 1}^n (c_i + \Phi(D_i) - \Phi(D_{i - 1})) = \sum_{i = 1}^n c_i + \Phi(D_n) - \Phi(D_0).$$
Если функцию потенциала $\Phi$ можно определить таким образом, чтобы выполнялось неравенство $\Phi(D_n) \ge \Phi(D_0)$, то полная амортизированная стоимость $\sum_{i = 1}^n \hat{c_i}$ является верхней границей полной фактической стоимости $\sum_{i = 1}^n c_i$.
На практике не всегда известно, сколько операций может быть выполнено, поэтому, если наложить условие $\Phi(D_i) \ge \Phi(D_0)$ для всех $i$, то, как и в методе бухгалтерского учета, будет обеспечена предоплата.
Часто удобно определить величину $\Phi(D_0)$ равной нулю, а затем показать, что для всех $i$ выполняется неравенство $\Phi(D_i) \ge 0$.

\subsubsection{Расширение динамической таблицы}

В некоторых приложениях заранее не известно, сколько элементов будет храниться в таблице.
Может возникнуть ситуация, когда для таблицы выделяется место, а впоследствии оказывается, что его недостаточно.
В этом случае приходится выделять больший объем памяти и копировать все объекты из исходной таблицы в новую, большего размера.
Аналогично, если из таблицы удаляется много объектов, может понадобиться преобразовать ее в таблицу меньшего размера.
Рассмитрим задачу о динамическом расширении и сжатии таблицы.
Методом амортизационного анализа будет показано, что амортизированная стоимость вставки и удаления равна всего лишь $O(1)$, даже если фактическая стоимость операции больше из-за того, что она приводит к расширению или сжатию таблицы.

Предполагается, что в динамической таблице поддерживаются операции
Table-Insert и Table-Delete.
В результате выполнения операции Table-Insert в таблицу добавляется элемент, занимающий одну ячейку (slot), --- пространство для одного элемента.
Аналогично операцию Table-Delete можно представлять как удаление элемента из таблицы, в результате чего одна ячейка освобождается.

Предположим, что место для хранения таблицы выделяется в виде массива ячеек. В некоторых программных средах при попытке вставить элемент в заполненную таблицу не остается ничего другого, как прибегнуть к аварийному завершению программы, сопровождаемому выдачей сообщения об ошибке.
Однако мы предполагаем, что наша программная среда, подобно многим современным средам, обладает системой управления памятью, позволяющей по запросу выделять и освобождать блоки памяти.
Таким образом, когда в заполненную таблицу вставляется элемент, ее можно \textbf{расширить} (expand), выделив место для новой таблицы, содержащей больше ячеек, чем было в старой.
Поскольку таблица всегда должна размещаться в непрерывной области памяти, для большей таблицы необходимо выделить новый массив, а затем скопировать элементы из старой таблицы в новую.

Общепринятый эвристический подход заключается в том, чтобы в новой таблице было в два раза больше ячеек, чем в старой.
Если в таблицу элементы только вставляются, то значение ее коэффициента заполнения будет не меньше 1/2, поэтому объем неиспользованного места никогда не превысит половины полного
размера таблицы.

В приведенном ниже псевдокоде предполагается, что $T$ --- объект, представляющий таблицу.
Атрибут $T.table$ содержит указатель на блок памяти, представляющий таблицу.
В $T.num$ содержится количество элементов в таблице, а в $T.size$ --- полное количество ячеек в таблице.
Изначально таблица пустая: $T. num = T. size = 0$.

\begin{minted}{c}
Table-Insert (Т, х)
    if Т.size == 0
        Выделить Т.table с 1 ячейкой
        T.size = 1
    if Т.num == Т.size
        Выделить new-table с 2 T.size ячейками
        Вставить все элементы из Т.table в new-table
        Освободить Т.table
        Т.table = new-table
        Т.size = 2 Т.size
    Вставить x в Т.table
    Т.num = Т.num + 1
\end{minted}

Здесь имеется две “вставки” (сама процедура Table-Insert и операция \textbf{элементарной вставки} (elementary insertion) в таблицу), выполняемые в строках 6 и 10.
Время работы процедуры Table-Insert можно проанализировать в терминах количества элементарных вставок, считая стоимость каждой такой операции равной 1.
Предполагается, что фактическое время работы процедуры Table-Insert линейно зависит от времени вставки отдельных элементов, так что накладные расходы на выделение исходной таблицы в строке 2 --- константа, а накладные расходы на выделение и освобождение памяти в строках 5 и 7 пренебрежимо малы по сравнению со стоимостью переноса элементов в строке 6.
Назовем \textbf{расширением} (expansion) событие, при котором выполняются строки 5--9.

Определим функцию потенциала $\Phi$, которая становится равной 0 сразу после расширения и достигает значения, равного размеру матрицы, к тому времени, когда матрица станет заполненной.
В этом случае предстоящее расширение можно будет оплатить за счет потенциала.
Одним из возможных вариантов является функция $$\Phi(T) = 2 \cdot T.num - T.size.$$
Сразу после расширения выполняется соотношение $T.num = T.size/2$, поэтому, как и требуется, $\Phi(T) = 0$.
Непосредственно перед расширением справедливо равенство $T.num = T.size$, следовательно, как и требуется, $\Phi(T) = T.num$.
Начальное значение потенциала равно 0, и, поскольку таблица всегда заполнена не менее чем наполовину, выполняется неравенство $T.num \ge T.size / 2$, из которого следует, что функция $\Phi(T)$ всегда неотрицательна.
Таким образом, суммарная амортизированная стоимость $n$ операций Table-Insert является верхней границей суммарной фактической стоимости.

Чтобы проанализировать амортизированную стоимость $i$-й операции Table-Insert, обозначим через $num_i$ количество элементов, хранящихся в таблице после этой операции, через $size_i$ --- общий размер таблицы после этой операции и через $\Phi_i$ --- потенциал после этой операции.
Изначально $num_0 = 0$, $size_0 = 0$ и $\Phi_0 = 0$.
Если $i$-я операция Table-Insert не приводит к расширению, то $size_i = size_{i-1}$ и амортизированная стоимость операции равна 
\begin{align*}
    \hat{c_i} &= c_i + \Phi_i - \Phi_{i - 1} \\
    &= 1 + (2 \cdot num_i - size_i) - (2 \cdot num_{i - 1} - size_{i - 1}) \\
    &= 1 + (2 \cdot num_i - size_i) - (2 \cdot (num_i - 1) - size_i) \\
    &= 3.
\end{align*}

Если же $i$-я операция Table-Insert приводит к расширению, то $size_i = 2 \cdot size_{i - 1}$ и $size_{i - 1} = num_{i - 1} = num_i - 1$, откуда вытекает, что $size_i = 2 \cdot (num_i -1)$.
Таким образом, амортизированная стоимость операции равна
\begin{align*}
    \hat{c_i} &= c_i + \Phi_i - \Phi_{i - 1} \\
    &= num_i + (2 \cdot num_i - size_i) - (2 \cdot num_{i - 1} - size_{i - 1}) \\
    &= num_i + (2 \cdot num_i - (num_i - 1)) - (2 \cdot (num_i - 1) - (num_i - 1)) \\
    &= num_i + 2 - (num_i - 1) \\
    &= 3.
\end{align*}
