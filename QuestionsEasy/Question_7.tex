\section{Алгоритмы поиска кратчайших путей. Алгоритм Дейкстры, алгоритм Беллмана-Форда. }

	
\subsection{Алгоритм Дейкстры}

\begin{definition}
	\textbf{Алгоритм Дейкстры} --- это алгоритм на графах, который находит кратчайшие пути от одной вершины (источника) до всех остальных вершин в графе со взвешенными рёбрами, при условии, что веса всех рёбер неотрицательны.
\end{definition}

\noindent \textbf{Входные данные:}
\begin{itemize}
	\item Взвешенный ориентированный или неориентированный граф $G=(V, E)$, где $V$ --- множество вершин, $E$ --- множество рёбер.
	\item Функция веса рёбер $w: E \to \mathbb{R}_{\ge 0}$, где $w(u,v) \ge 0$ для всех $(u,v) \in E$.
	\item Исходная вершина (источник) $s \in V$.
\end{itemize}

\noindent \textbf{Выходные данные:}
\begin{itemize}
	\item Для каждой вершины $v \in V$ --- длина кратчайшего пути от $s$ до $v$, $d[v]$.
	\item Для каждой вершины $v \in V$ (кроме $s$) --- предшествующая вершина на кратчайшем пути от $s$, $p[v]$.
\end{itemize}

\subsubsection{Инициализация}
Для всех вершин $v \in V$:
$d[v] = +\infty$, $p[v] = \text{NULL}$.
$d[s] = 0$.

Создаём приоритетную очередь $PQ$, в которую добавляем пары $(d[v], v)$ для всех вершин $v$.
В начале $PQ$ содержит только $(0, s)$.

\subsubsection{Шаг алгоритма}
Пока $PQ$ не пуста:
\begin{enumerate}
	\item Извлекаем из $PQ$ вершину $u$ с минимальным значением $d[u]$.
	\item Для каждого соседа $v$ вершины $u$:
	\begin{itemize}
		\item Если $d[u] + w(u,v) < d[v]$:
		\begin{itemize}
			\item $d[v] = d[u] + w(u,v)$.
			\item $p[v] = u$.
			\item Обновляем приоритет $v$ в $PQ$ (или добавляем, если $v$ ещё нет в $PQ$).
		\end{itemize}
	\end{itemize}
\end{enumerate}

\subsubsection{Время работы}
Время работы алгоритма Дейкстры зависит от реализации приоритетной очереди $Q$:
\begin{itemize}
	\item \textbf{Массив:} $O(V^2)$ (для каждой из $V$ вершин осуществляется поиск в массиве за $O(V)$).
	\item \textbf{Бинарная куча:} $O((|V| + |E|) \log |V|) = O(E \log V)$ (в ходе алгоритма каждое ребро из $E$ будет добавлено/удалено из бинарной кучи за $O(\log V)$)
	\item \textbf{Фибоначчиева куча:} $O(|E| + |V| \log |V|)$.
\end{itemize}

\subsection{Доказательство корректности алгоритма Дейкстры}

Доказательство корректности алгоритма Дейкстры основывается на \textbf{инварианте}, который поддерживается на каждом шаге.

\begin{theorem}[Корректность алгоритма Дейкстры]
	Когда алгоритм Дейкстры завершается, для каждой вершины $v \in V$, $d[v]$ равно длине кратчайшего пути от источника $s$ до $v$.
\end{theorem}

\begin{proof}
	Докажем по индукции, что в момент посещения любой вершины $u$, $d[u] = \delta(s,u)$.
	
	\textbf{База индукции:}
	На первом шаге выбирается $s$. Для неё выполнено $d[s] = \delta(s,s) = 0$.
	
	\textbf{Индукционный шаг:}
	Предположим, что для $n$ первых шагов алгоритм сработал верно и на $n+1$ шагу выбрана вершина $u$. Докажем, что в этот момент $d[u] = \delta(s,u)$.
	Для начала отметим, что для любой вершины $v$, всегда выполняется $d[v] \ge \delta(s,v)$ (алгоритм не может найти путь короче, чем кратчайший из всех существующих).
	Пусть $P$ --- кратчайший путь из $s$ в $u$.
	Пусть $z$ --- последняя посещённая вершина на пути $P$, а $v$ --- первая непосещённая вершина на $P$, следующая за $z$.
	Поскольку $P$ кратчайший путь, его часть, ведущая через $z$ в $v$, тоже кратчайшая, следовательно $\delta(s,v) = \delta(s,z) + w(z,v)$.
	По предположению индукции, в момент посещения вершины $z$ выполнялось $d[z] = \delta(s,z)$.
	Следовательно, вершина $v$ получила метку не больше, чем $d[z] + w(z,v) = \delta(s,z) + w(z,v) = \delta(s,v)$. То есть, $d[v] = \delta(s,v)$.
	
	С другой стороны, поскольку сейчас мы выбрали вершину $u$, её метка минимальна среди непосещённых, то есть $d[u] \le d[v]$.
	Комбинируя это с $d[v] = \delta(s,v) \le \delta(s,u)$ (поскольку $P$ --- кратчайший путь и все веса неотрицательны), мы имеем $d[u] \le \delta(s,u)$.
	Поскольку, как было сказано ранее, $d[u]$ всегда $\ge \delta(s,u)$,
	то $d[u] = \delta(s,u)$, что и требовалось доказать.
	
	Поскольку алгоритм заканчивает работу, когда все вершины посещены, в этот момент $d[u] = \delta(s,u)$ для всех $u$.
\end{proof}

\begin{remark}
	Важное условие для корректности алгоритма Дейкстры --- это \textbf{неотрицательные веса рёбер}. Для графов с отрицательными весами используются другие алгоритмы, такие как Беллмана-Форда.
\end{remark}

\subsection{Алгоритм Беллмана --- Форда}

\begin{definition}
	\textbf{Алгоритм Беллмана-Форда} (англ. Bellman-Ford algorithm) --- это алгоритм на графах, который находит кратчайшие пути от одной вершины (источника) до всех остальных вершин в графе со взвешенными рёбрами. В отличие от алгоритма Дейкстры, он может работать с графами, содержащими рёбра отрицательного веса, и способен обнаруживать циклы отрицательного веса.
\end{definition}

\noindent \textbf{Входные данные:}
\begin{itemize}
	\item Взвешенный ориентированный или неориентированный граф $G=(V, E)$, где $V$ --- множество вершин, $E$ --- множество рёбер.
	\item Функция веса рёбер $w: E \to \mathbb{R}$. Веса могут быть отрицательными.
	\item Исходная вершина (источник) $s \in V$.
\end{itemize}

\noindent \textbf{Выходные данные:}
\begin{itemize}
	\item Если граф не содержит циклов отрицательного веса, достижимых из $s$:
	\begin{itemize}
		\item Для каждой вершины $v \in V$ --- длина кратчайшего пути от $s$ до $v$, $d[v]$.
		\item Для каждой вершины $v \in V$ (кроме $s$) --- предшествующая вершина на кратчайшем пути от $s$, $p[v]$.
	\end{itemize}
	\item Если граф содержит цикл отрицательного веса, достижимый из $s$: возвращает признак наличия такого цикла.
\end{itemize}

\subsubsection{Идея алгоритма}
Алгоритм Беллмана-Форда использует принцип динамического программирования. Он итеративно релаксирует все рёбра графа $|V|-1$ раз. На $k$-й итерации алгоритм гарантирует, что найдены кратчайшие пути, состоящие максимум из $k$ рёбер. Поскольку кратчайший путь в графе без отрицательных циклов может содержать максимум $|V|-1$ рёбер, $|V|-1$ итераций достаточно. Дополнительная $|V|$-я итерация используется для обнаружения отрицательных циклов.

\subsubsection{Псевдокод}
\noindent \textbf{Инициализация:}
Для всех вершин $v \in V$:
$d[v] = +\infty$, $p[v] = \text{NULL}$.
$d[s] = 0$.

\noindent \textbf{Шаг алгоритма (Фаза релаксации):}
\begin{minted}{c}
for k = 0 to |V| - 2
  // вершины нумеруются с единицы
  for v in V
    for  (u,v) in E
      d[k + 1][v] = min(d[k + 1][v], d[k][u] + ω(u,v))  
      // ω(u,v) - вес ребра uv
\end{minted}

\subsubsection{Время работы}
Время работы алгоритма Беллмана-Форда: $O(|V| \cdot |E|)$.
Это обусловлено тем, что во фазе релаксации выполняется $|V|-1$ итераций, и на каждой итерации просматриваются все $|E|$ рёбер. Фаза обнаружения также просматривает все $|E|$ рёбер один раз.

\subsection{Доказательство корректности алгоритма Беллмана-Форда}

\begin{theorem}[Корректность алгоритма Беллмана-Форда]
	Если граф $G$ не содержит циклов отрицательного веса, достижимых из $s$, то после $|V|-1$ итераций фазы релаксации, $d[v]$ равно длине кратчайшего пути от $s$ до $v$ для всех $v \in V$.
	Если после $|V|-1$ итераций возможно дальнейшее улучшение $d[v]$ для какого-либо ребра $(u,v)$, то в графе существует цикл отрицательного веса, достижимый из $s$.
\end{theorem}

\begin{proof}
	Докажем, что после $k$-й итерации алгоритма, $d[v]$ содержит длину кратчайшего пути от $s$ до $v$, состоящего максимум из $k$ рёбер, или, по крайней мере, оценивает её сверху.
	
	\textbf{Лемма 1: Верхняя граница.}
	Для любой вершины $v$, $d[v]$ всегда $\ge \delta(s,v)$ (где $\delta(s,v)$ --- истинная длина кратчайшего пути).
	Доказательство: Инициализация устанавливает $d[s]=0=\delta(s,s)$ и $d[v]=\infty$ для $v \ne s$. Каждая релаксация $d[v] = d[u] + w(u,v)$ сохраняет это свойство: если $d[u] \ge \delta(s,u)$ и $w(u,v) \ge \delta(u,v)$ (что верно, так как $w(u,v)$ --- это вес ребра, а не путь), то $d[u] + w(u,v) \ge \delta(s,u) + \delta(u,v) \ge \delta(s,v)$ (по неравенству треугольника для кратчайших путей). Таким образом, $d[v]$ никогда не становится меньше истинного кратчайшего пути.
	
	\textbf{Лемма 2: Корректность после $k$ итераций.}
	После $k$-й итерации фазы релаксации, если существует кратчайший путь от $s$ до $v$, состоящий из $k$ или менее рёбер, то $d[v]$ равно длине этого кратчайшего пути.
	Доказательство по индукции по $k$:
	\textbf{База индукции ($k=0$):} $d[s]=0$, что верно для пути из 0 рёбер.
	\textbf{Индукционный шаг:} Предположим, что лемма верна для $k-1$ итерации.
	Рассмотрим кратчайший путь $P = s \leadsto x \to v$, состоящий из $k$ рёбер. Пусть $(x,v)$ --- последнее ребро на этом пути. Тогда часть пути $s \leadsto x$ состоит из $k-1$ рёбер и является кратчайшим путём от $s$ до $x$ из $k-1$ рёбер.
	По индукционному предположению, после $k-1$ итераций, $d[x]$ уже было равно $\delta(s,x)$.
	На $k$-й итерации, когда мы просматриваем ребро $(x,v)$, произойдёт релаксация (если ещё не произошло), и $d[v]$ будет обновлено до $d[x] + w(x,v) = \delta(s,x) + w(x,v) = \delta(s,v)$.
	Таким образом, после $k$ итераций, $d[v]$ будет содержать истинную длину кратчайшего пути длиной до $k$ рёбер.
	
	\textbf{Завершение доказательства теоремы:}
	По лемме 2 после $|V| - 1$ шага будет получено корректный кратчайший путь длины не более $|V| - 1$ $\Rightarrow$ мы получили корректный путь (все остальные пути будут непростыми, а значит, в отсутствие отрицательных циклов, не могут уменьшить ответ)
\end{proof}

\begin{remark}
	Алгоритм Беллмана-Форда более универсален, чем Дейкстра, так как он может обрабатывать отрицательные веса рёбер. Однако его асимптотическая сложность $O(|V| \cdot |E|)$ выше, чем у Дейкстры.
\end{remark}
