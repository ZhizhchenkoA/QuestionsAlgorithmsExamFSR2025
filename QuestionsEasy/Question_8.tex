\section{Остовные деревья. Алгоритмы Прима, Краскала, Борувки.}

\textbf{Остовное дерево связного графа} --- это ациклический связный подграф (дерево), в который входят все вершины данного графа.

Пусть $T$ --- \textit{ациклическое поддерево} $T\subseteq E$ графа $G=(V, E)$, которое \textit{соединяет все вершины} $G$ и \textit{вес} которого \textit{минимален}.
Задача поиска такого $T$ --- это задача поиска \textbf{минимального остовного дерева}.

Для этого используют алгоритмы \textbf{Прима}, \textbf{Краскала} и \textbf{Борувки}. Они жадные (т.е. выбирают вариант, лучший в данный момент).
\subsection{Алгоритм Краскала}
\begin{enumerate}
	\item Вначале создаётся пустое множество рёбер
	\item Пока возможно, из всех рёбер, добавление которых к имеющемуся множеству не вызовет появления цикла, выбирается ребро минимального веса и добавляется к имеющемуся множеству
	\item Когда таких рёбер больше нет, алгоритм завершает свою работу
\end{enumerate}
Исходное множество ребёр можно отсортировать по весу за $O(E\log{E})$ (Таким образом, необходимое для добавления ребро можно найти не более, чем за $O(E)$, когда в случае неотсортированного массива поиск минимума затратит $O(E)$, поиск второго также за $O(E)$ и т.д.)

Временная сложность алгоритма Краскала: $O(E\log{E})$
(На самом деле $O(E(logE+\alpha(V)))$, но функция, обратная функции Аккермана на реальных данных сильно ограничена, поэтому мы ей пренебрегаем)

\subsection{Алгоритм Прима}

\begin{enumerate}
	% \item Для каждого ребра задаётся его стоимость 
	\item Берём произвольную вершину, находим ребро, инцидентное данной вершине (с наименьшей стоимостью)
	\item Затем рассмотрим рёбра графа, один конец которых принадлежит дереву, а другой нет. Из них выбираем то ребро, стоимость которого наименьшая.
	\item Присоединим выбранное ребро к дереву.
	\item Рост дерева происходит пока не будут исчерпаны все вершины графа.
\end{enumerate}
Временная сложность алгоритма Прима: $O(E\log{V})$ (при реализации на бинарной куче)

$O(V^2)$  при реализации очереди с приоритетом на массиве

\subsection{Алгоритм Борувки}

\begin{enumerate}
	\item Каждая вершина $G$ - тривиальное дерево
	\item Для каждого дерева $T$ найдём ребро с минимальным весом, инцидентных ему.
	\item Добавим все такие рёбра (объединим те деревья, которые соединились общим ребром)
	\item Остановимся, когда в графе останется только одно дерево $T$.
\end{enumerate}
Временная сложность алгоритма Борувки: $O(E\log{V})$