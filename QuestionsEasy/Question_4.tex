\section{Бинарные деревья поиска. Вставка, удаление, оценки сложности.}

\subsection*{Бинарное дерево поиска}
Структура данных, где каждый отдельно взятый элемент дерева состоит из данных, указателя на левого потомка, указателя на правого потомка, и (опционально) указателя на родителя.

\textbf{Свойство:} Для узла $x$ все узлы в левом поддереве меньше $x$, а в правом поддереве больше $x$.
\begin{itemize}
	\item Нет потомков --- лист.
	\item Нет родителя --- корень.
\end{itemize}

\subsection*{Обход дерева поиска:}
\begin{itemize}
	\item Обход узлов в отсортированном порядке.
	\item Обход узлов в \textit{прямом} порядке: вершина, левое поддерево, правое поддерево.
	\item Обход узлов в \textit{обратном} порядке: левое поддерево, правое поддерево, вершина.
\end{itemize}

\subsection*{Поиск элемента:}
В дереве $T$ ищем ключ $k$. Проверить, есть ли узел с ключом $k$, вернуть ссылку на узел.
\textbf{Алгоритм:}
\begin{itemize}
	\item Если дерево пусто, сообщить, что узел не найден, и стоп.
	\item Иначе сравнить $k$ со значением ключа корневого узла $x$.
	\item Если $k=x$, выдать ссылку на этот узел, остановиться.
	\item Если $k>x$, рекурсивно искать ключ $k$ в правом поддереве.
	\item Если $k<x$, рекурсивно искать ключ $k$ в левом поддереве.
\end{itemize}
\textbf{Сложность:}
\begin{itemize}
	\item Если дерево сбалансировано: $O(\log n)$.
	\item Если дерево без развилок (бамбук): $O(n)$, где $n$ --- высота дерева.
\end{itemize}

\subsection*{Добавление элемента:}
\begin{itemize}
	\item Если дерево пусто, замещаем его новым узлом (наш элемент) и останавливаемся.
	\item Иначе сравниваем $k$ с ключом корневого узла $x$.
	\item Если $k=x$, заменить текущий узел новым значением.
	\item Если $k<x$, рекурсивно добавить в левое поддерево.
	\item Если $k>x$, рекурсивно добавить в правое поддерево.
\end{itemize}
\textbf{Сложность:} $O(h)$, где $h$ --- высота дерева.

\subsection*{Удаление элемента:}
\begin{itemize}
	\item Если дерево пусто, остановиться.
	\item Иначе сравнить $k$ с ключом корневого узла $x$.
	\item Если $k>x$, рекурсивно удалить из правого поддерева.
	\item Если $k<x$, рекурсивно удалить $k$ из левого поддерева.
	\item Если $k=x$, рассмотрим 3 случая:
	\begin{enumerate}
		\item Нет обоих потомков: удаляем текущий узел и обнуляем ссылку на него.
		\item Есть один потомок: перекидываем с него у родительского узла ссылку на потомка, ссылку на родителя потомка перекидываем на его родителя. Удаляем узел.
		\item Есть оба потомка:
		\begin{itemize}
			\item Если левый узел правого поддерева отсутствует: копируем из правого узла в удаляемый поле ($k,U$).
			\item Иначе: возьмём самый левый узел из правого поддерева. Скопируем данные из него в удаляемый. Рекурсивно удалим его.
		\end{itemize}
	\end{enumerate}
\end{itemize}
\textbf{Сложность:} $O(h)$, где $h$ --- высота дерева.